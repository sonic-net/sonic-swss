#include "bfdsyncd/bfdlink.h"

#include <swss/netdispatcher.h>

#include <gtest/gtest.h>
#include <gmock/gmock.h>

using namespace swss;
using namespace testing;

using ::testing::_;
using ::testing::NiceMock;
using ::testing::Return;

#define STATE_UPDATE_MSG_LEN 36
#define COUNTER_MSG_LEN 80

class MockBfdLink : public BfdLink
{
public:
    MockBfdLink(DBConnector *db, DBConnector *stateDb, unsigned short port = BFD_DATA_PLANE_DEFAULT_PORT, int debug = 0):BfdLink(db, stateDb, port, debug){}
    MOCK_METHOD(bool, sendmsg, (uint16_t msglen), ());
    MOCK_METHOD(string, exec, (const char* cmd), (override));
    MOCK_METHOD(string, get_intf_mac, (const char* intf), (override));
};


class BfdSyncdTest : public ::testing::Test
{
public:
    void SetUp() override
    {
    }

    void TearDown() override
    {
    }

    DBConnector m_appl_db{"APPL_DB", 0};
    DBConnector m_state_db{"STATE_DB", 0};
    NiceMock<MockBfdLink>  m_bfd{&m_appl_db, &m_state_db, BFD_DATA_PLANE_DEFAULT_PORT, 1};

};

TEST_F(BfdSyncdTest, SingleMessageInBfdMessage)
{
    shared_ptr<swss::DBConnector> app_db;
    app_db = make_shared<swss::DBConnector>("APPL_DB", 0);
    Table app_bfd_session_table(app_db.get(), APP_BFD_SESSION_TABLE_NAME);

    //Create BFD session
    unsigned char s[] = {
        0x01, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x8c, 0x00, 0x00, 0x00, 0x10, 0xfe, 0x80, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x7a, 0xa4, 0x3e, 0xff, 0xfe, 0x72, 0xac, 0x00, 0xfe, 0x80, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x7a, 0x11, 0x08, 0xff, 0xfe, 0x55, 0xd4, 0x00, 0x24, 0x08, 0xc7, 0x9e,
        0x00, 0x04, 0x93, 0xe0, 0x00, 0x04, 0x93, 0xe0, 0x00, 0x00, 0xc3, 0x50, 0x00, 0x00, 0xc3, 0x50,
        0x00, 0x00, 0x00, 0x00, 0xff, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4a, 0x45, 0x74, 0x68, 0x65,
        0x72, 0x6e, 0x65, 0x74, 0x31, 0x5f, 0x31, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    };

    ON_CALL(m_bfd, get_intf_mac(_)).WillByDefault(Return("78:12:83:58:08:00"));
    ON_CALL(m_bfd, exec(_)).WillByDefault(Return("78:12:83:58:08:01"));

    memcpy(m_bfd.m_messageBuffer, static_cast<void *>(s), sizeof(s));

    m_bfd.handleBfdDpMessage(0);

    //Check APPL DB
    {
        vector<string> keys;
        vector<FieldValueTuple> fieldValues;
        string multihop;
        string local_addr;
        string dst_mac;
        string src_mac;
        string rx_interval;
        string tx_interval;
        string multiplier;

        app_bfd_session_table.getKeys(keys);
        ASSERT_EQ(keys.size(), 1);

        app_bfd_session_table.get(keys[0], fieldValues);
        for (const auto& fv: fieldValues)
        {
            const auto& field = fvField(fv);
            const auto& value = fvValue(fv);

            if (field == "multihop")    multihop = value;
            if (field == "local_addr")  local_addr = value;
            if (field == "dst_mac")     dst_mac = value;
            if (field == "src_mac")     src_mac = value;
            if (field == "rx_interval") rx_interval = value;
            if (field == "tx_interval") tx_interval = value;
            if (field == "multiplier" ) multiplier = value;
        }
        ASSERT_EQ( multihop, "false");
        ASSERT_EQ( local_addr, "fe80::7aa4:3eff:fe72:ac00");
        ASSERT_EQ( dst_mac, "78:12:83:58:08:01");
        ASSERT_EQ( src_mac, "78:12:83:58:08:00");
        ASSERT_EQ( rx_interval, "300");
        ASSERT_EQ( tx_interval, "300");
        ASSERT_EQ( multiplier, "3");
    }

    //Update BFD session state, call sendmsg
    {
        EXPECT_CALL(m_bfd, sendmsg(STATE_UPDATE_MSG_LEN)).Times(1);

        std::vector<FieldValueTuple> fieldValues = {
            {"state", "Up"},
        };
        auto key = string("default|Ethernet1_1|fe80::7a11:8ff:fe55:d400");
        m_bfd.handleBfdStateUpdate(key, fieldValues);

    }

    //handle counter request
    {
        EXPECT_CALL(m_bfd, sendmsg(COUNTER_MSG_LEN)).Times(1);

        unsigned char s[] = {
            0x01, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x8c, 0x00, 0x00, 0x00, 0x10, 0xfe, 0x80, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x7a, 0xa4, 0x3e, 0xff, 0xfe, 0x72, 0xac, 0x00, 0xfe, 0x80, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x7a, 0x11, 0x08, 0xff, 0xfe, 0x55, 0xd4, 0x00, 0x24, 0x08, 0xc7, 0x9e,
            0x00, 0x04, 0x93, 0xe0, 0x00, 0x04, 0x93, 0xe0, 0x00, 0x00, 0xc3, 0x50, 0x00, 0x00, 0xc3, 0x50,
            0x00, 0x00, 0x00, 0x00, 0xff, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4a, 0x45, 0x74, 0x68, 0x65,
            0x72, 0x6e, 0x65, 0x74, 0x31, 0x5f, 0x31, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
        };

        memcpy(m_bfd.m_messageBuffer, static_cast<void *>(s), sizeof(s));

        m_bfd.handleBfdDpMessage(0);
    }

    //Delete BFD session and Check APPL DB
    {
        unsigned char s[] = {
            0x01, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x8c, 0x00, 0x00, 0x00, 0x10, 0xfe, 0x80, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x7a, 0xa4, 0x3e, 0xff, 0xfe, 0x72, 0xac, 0x00, 0xfe, 0x80, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x7a, 0x11, 0x08, 0xff, 0xfe, 0x55, 0xd4, 0x00, 0x24, 0x08, 0xc7, 0x9e,
            0x00, 0x04, 0x93, 0xe0, 0x00, 0x04, 0x93, 0xe0, 0x00, 0x00, 0xc3, 0x50, 0x00, 0x00, 0xc3, 0x50,
            0x00, 0x00, 0x00, 0x00, 0xff, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4a, 0x45, 0x74, 0x68, 0x65,
            0x72, 0x6e, 0x65, 0x74, 0x31, 0x5f, 0x31, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
        };

        memcpy(m_bfd.m_messageBuffer, static_cast<void *>(s), sizeof(s));

        m_bfd.handleBfdDpMessage(0);

        vector<string> keys;
        vector<FieldValueTuple> fieldValues;

        app_bfd_session_table.getKeys(keys);
        ASSERT_EQ(keys.size(), 0);
    }

    //Update BFD session state, expecting session is not found, no message sent
    {
        EXPECT_CALL(m_bfd, sendmsg(STATE_UPDATE_MSG_LEN)).Times(0);

        std::vector<FieldValueTuple> fieldValues = {
            {"state", "Up"},
        };
        auto key = string("default|Ethernet1_1|fe80::7a11:8ff:fe55:d400");
        m_bfd.handleBfdStateUpdate(key, fieldValues);
    }
}

